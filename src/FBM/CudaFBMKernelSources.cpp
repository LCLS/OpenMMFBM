#include "FBM/CudaFBMKernelSources.h"

using namespace OpenMM;
//using namespace OpenMMFBM;
using namespace std;


/* This function perturbs each element of the vector initpos by delta
 * and places the result in blockpos.
 * Note you can do a negative perturbation by passing a delta < 0
 * The function assumes threads and blocks to be organized linearly
 */
const string CudaFBMKernelSources::perturb = "__global__ void perturbPositions(float* blockpos, float4* initpos, float delta, int* blocks, int numblocks, int setnum, int N) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"\n"
		"   if(blockNum >= numblocks) {\n"
		"      return;\n"
		"   }\n"
		"\n"
		"   int dof = 3*blocks[blockNum]+setnum;\n"
		"   int atom = dof/3;\n"
		"\n"
		"   if (atom >= N || (blockNum != (numblocks-1) && atom >= blocks[blockNum+1])) return;\n"
		"\n"
		"\n"
		"   int axis = dof % 3;\n"
		"\n"
		"\n"
		"   if(axis == 0) {\n"
		"      blockpos[dof] = initpos[atom].x;\n"
		"      initpos[atom].x += delta;\n"
		"   } else if(axis == 1) {\n"
		"      blockpos[dof] = initpos[atom].y;\n"
		"     initpos[atom].y += delta;\n"
		"   } else {\n"
		"      blockpos[dof] = initpos[atom].z;\n"
		"     initpos[atom].z += delta;\n"
		"   }\n"
		"\n"
		"\n"
		"}\n"
		"\n"
		"__global__ void perturbByE(float* tmppos, float4* mypos, float eps, float* E, float* masses, int k, int m, int N) {\n"
		"   int dof = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   if (dof >= N) return;\n"
		"   int atom = dof/3;\n"
		" \n"
		"   int axis = dof % 3;\n"
		"   if (axis == 0) {\n"
		"      tmppos[dof] = mypos[atom].x;\n"
		"      mypos[atom].x += eps*E[dof*m+k] / sqrt(masses[atom]);\n"
		"   }\n"
		"   else if (axis == 1) {\n"
		"      tmppos[dof] = mypos[atom].y;\n"
		"      mypos[atom].y += eps*E[dof*m+k] / sqrt(masses[atom]);\n"
		"   }\n"
		"   else {\n"
		"      tmppos[dof] = mypos[atom].z;\n"
		"      mypos[atom].z += eps*E[dof*m+k] / sqrt(masses[atom]);\n"
		"   }\n"
		"}\n"
		"\n"
		"";

const string CudaFBMKernelSources::copy = "__global__ void blockcopyFromOpenMM(float* target, float* source, int* blocks, int numblocks, int setnum, int N) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int dof = 3*blocks[blockNum]+setnum;\n"
		"   int atom = dof/3;\n"
		"   \n"
		"   if (atom >= N || (blockNum != numblocks && atom >= blocks[blockNum+1])) return;  // Out of bounds\n"
		"\n"
		"   target[dof]= *( source + (dof+atom+1)*sizeof(float) ); // Save the old\n"
		"}\n"
		"\n"
		"__global__ void blockcopyToOpenMM(float* target, float* source, int* blocks, int numblocks, int setnum, int N) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int dof = 3*blocks[blockNum]+setnum;\n"
		"   int atom = dof/3;\n"
		"   \n"
		"   if (atom >= N || (blockNum != numblocks && atom >= blocks[blockNum+1])) return;  // Out of bounds\n"
		"\n"
		"   *( target + (dof+atom+1)*sizeof(float) ) = source[dof]; // Save the old\n"
		"}\n"
		"\n"
		"\n"
		"__global__ void copyFromOpenMM(float* target, float* source, int N) {\n"
		"   int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int atom = elementNum/3;\n"
		"   if (elementNum > N) return;\n"
		"   else target[elementNum] = source[4*atom + elementNum%3]; \n"
		"}\n"
		"\n"
		"__global__ void copyToOpenMM(float* target, float* source, int N) {\n"
		"   int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int atom = elementNum / 3;\n"
		"   if (elementNum > N) return;\n"
		"   //else target[elementNum] = source[elementNum];\n"
		"   else target[4*atom + elementNum%3] = source[elementNum];\n"
		"}\n"
		"";

/* This function will populate the matrix with block Hessians on the
 * diagonal (h) which is assumed to be two dimensional.
 * The function assumes that thread blocks are one-dimensional
 */


const string CudaFBMKernelSources::blockHess =  "__global__ void makeBlockHessian(float* h, float* forces1, float* forces2, float* mass, float blockDelta, int* blocks, int* blocksizes, int numblocks, int* hessiannums, int* hessiansizes, int setnum, int N) {\n"
		"   int blockNum = blockIdx.x*blockDim.x + threadIdx.x;\n"
		"   int dof = 3*blocks[blockNum]+setnum;\n"
		"   int atom = dof / 3;\n"
		"   if (atom >= N || (blockNum != numblocks-1 && atom >= blocks[blockNum+1])) return;  // Out of bounds\n"
		"\n"
		"   int start_dof = 3 * blocks[blockNum];\n"
		"   int end_dof;\n"
		"   if( blockNum == numblocks - 1)\n"
		"	end_dof = 3 * N;\n"
		"   else\n"
		"        end_dof = 3 * blocks[blockNum+1];\n"
		" \n"
		"   /* I also would like to parallelize this at some point as well */\n"
		"   for( int k = start_dof; k < end_dof; k++ ) {\n"
		"      float blockScale = 1.0 / (blockDelta * sqrt(mass[atom] * mass[k/3]));\n"
		"      //h[startspot+i] = (forces1[k] - forces2[k]) * blockScale;\n"
		"      h[hessiannums[blockNum] + (k-start_dof)*(3*blocksizes[blockNum]) + (dof - start_dof)] = (forces1[k] - forces2[k]) * blockScale;\n"
		"   }\n"
		"}\n"
		"";

/* Take a matrix, make it symmetric
 * Assumes a 2D block of threads
 */


const string CudaFBMKernelSources::symmetrize = "__global__ void symmetrize1D(float* h, int* blockPositions, int* blockSizes, int numBlocks) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   if (blockNum >= numBlocks) return;\n"
		"\n"
		"   // blockSizes are given in terms of atoms, convert to dof\n"
		"   const unsigned int blockSize = 3 * blockSizes[blockNum];\n"
		"\n"
		"   float* block = &(h[blockPositions[blockNum]]);\n"
		"   for(unsigned int r = 0; r < blockSize - 1; r++) {\n"
		"       for(unsigned int c = r + 1; c < blockSize; c++) {\n"
		"          const float avg = 0.5f * (block[r * blockSize + c] + block[c * blockSize + r]);\n"
		"          block[r * blockSize + c] = avg;\n"
		"          block[c * blockSize +	r] = avg;\n"
		"       }\n"
		"   }\n"
		"\n"
		"}\n"
		"\n"
		"__global__ void symmetrize2D(float* h, int natoms) {\n"
		"   const int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   const int dof = 3 * natoms;\n"
		"   if (elementNum >= dof * dof) return;\n"
		"   int r = elementNum / dof;\n"
		"   int c = elementNum % dof;\n"
		"\n"
		"   if (r > c) return;\n"
		"   else {\n"
		"        const float avg = 0.5 * (h[r * dof + c] + h[c * dof + r]);\n"
		" 	 h[r * dof + c] = avg;\n"
		"        h[c * dof + r] = avg;\n"
		"   }\n"
		"}\n"
		"";
/* Matrix multiplication kernel
 * From the CUDA programmer's guide, with modifications
 * Performs C = A * B
 * width is the number of columns in A and the number of rows in B
 */

const string CudaFBMKernelSources::matmul = "__global__ void MatMulKernel(float* C, float* A, float* B, int Aheight, int Awidth, int Bwidth)\n"
		"{\n"
		"    float result = 0;\n"
		"    int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"    if (elementNum > Aheight*Bwidth) return;\n"
		"    int row = elementNum / Bwidth;\n"
		"    int col = elementNum % Bwidth;\n"
		"    for (int e = 0; e < Awidth; e++)\n"
		"       result += A[row*Awidth+e] * B[e*Bwidth+col];\n"
		"    C[row*Bwidth+col] = result;\n"
		"}\n"
		"";

/*
 * makeEigenvalues()
 * float* eigenvalues: Will be populated by the function
 * float** eigenvectors: Will be populated by the function
 * float* blockHessian: A linear array containing the block Hessian
 *                      matrices in sorted order.  Note that these
 *                      have different sizes.  Thus block 1 (aXa) will
 *                      occupy slots 0 to a*a-1, block 2 (bXb) will
 *                      occupy slots a*a to b*b-1, and so on.
 * float* array1D: Eigenvectors as a linear array.
 * int* evecstarts: Array of starting positions of every eigenvector
 *                    in array1D.
 * int* blocknums: Array of starting atoms of each block.
 * int* blocksize: Array of sizes of each block.
 * int N: Total degrees of freedom.
 */
const string CudaFBMKernelSources::eigen = "__global__ void makeEigenvalues(float* eigenvalues, float* blockHessian, int* blocknums, int* blocksizes, int* hessiannums, int N, int numblocks) {\n"
		"   // elementnum is the degree of freedom (0 to 3n-1)\n"
		"   int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   if (elementNum >= N) return;\n"
		"\n"
		"   // b is the block number in which DOF elementnum resides\n"
		"   // blocknums contains atom numbers, so we must divide by 3\n"
		"   // We find the first index with an atom number larger than \n"
		"   // ours, and take one less (or numblocks-1 if we are at the end)\n"
		"   int b = 0;\n"
		"   while (b < numblocks) {\n"
		"      if (blocknums[b] > elementNum/3) break; \n"
		"      b++;\n"
		"   }\n"
		"   b--;\n"
		"\n"
		"   // 3*blocknums[b] is the starting degree of freedom for our block\n"
		"   // We must compute an offset from that, call it x.\n"
		"   int x = elementNum - 3*blocknums[b];\n"
		"\n"
		"   // We initialize our spot to hessiannums[b], which is the starting\n"
		"   // Hessian location for our block.\n"
		"   // We then want to take the diagonal entry from that offset \n"
		"   // So element (x,x)\n"
		"   int spot = hessiannums[b] + x*(3*blocksizes[b])+x;\n"
		"\n"
		"   eigenvalues[elementNum] = blockHessian[spot];\n"
		"}\n"
		"";

/* Odd-even sort
 * This will need to be called within a loop that runs from 0 to
 * the ceiling of N/2 - 1, where N is the number of eigenvalues
 * We assume a linear array of threads and it will be the caller's
 * responsibility to ensure the thread indices are in bounds
 * Note to self: There is a GPU Quicksort available, but I have to modify
 * it to also move around eigenvectors... challenging, striving for accuracy
 */
/* blockEigSort; Sorting within the blocks */
const string CudaFBMKernelSources::sort = "__global__ void oddEvenEigSort(float* eigenvalues, float* eigenvectors, int N, int odd=0) {\n"
		"   int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   elementNum *= 2;\n"
		"   if (odd) elementNum++;\n"
		"   if (elementNum >= N-1) return;\n"
		"\n"
		"   if (eigenvalues[elementNum] > eigenvalues[elementNum+1]) {\n"
		"      float tmp = eigenvalues[elementNum];\n"
		"      eigenvalues[elementNum] = eigenvalues[elementNum+1];\n"
		"      eigenvalues[elementNum+1] = tmp;\n"
		"\n"
		"      for (int i = 0; i < N; i++) {\n"
		"         tmp = eigenvectors[i*N+elementNum];\n"
		"	 eigenvectors[i*N+elementNum] = eigenvectors[i*N+elementNum+1];\n"
		"	 eigenvectors[i*N+elementNum+1] = tmp;\n"
		"      }\n"
		"   }\n"
		"}\n"
		"\n"
		"\n"
		"__global__ void blockEigSort(float* eigenvalues, float* eigenvectors, int* blocknums, int* blocksizes, int N) {\n"
		"   int blockNumber = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int startspot = blocknums[blockNumber];\n"
		"   int endspot = startspot+blocksizes[blockNumber]-1;\n"
		"\n"
		"   // Bubble sort for now, thinking blocks are relatively small\n"
		"   // We may fix it later\n"
		"   for (int i = startspot; i < endspot; i++) {\n"
		"      for (int j = startspot; j < i; j++) {\n"
		"         if (eigenvalues[j] > eigenvalues[j+1])\n"
		"	    {\n"
		"               float tmp = eigenvalues[j];\n"
		"               eigenvalues[j] = eigenvalues[j+1];\n"
		"               eigenvalues[j+1] = tmp;\n"
		"\n"
		"               // Swapping addresses\n"
		"      		for (int i = 0; i < N; i++) {\n"
		"         		tmp = eigenvectors[i*N+j];\n"
		"			eigenvectors[i*N+j] = eigenvectors[i*N+j+1];\n"
		"	 		eigenvectors[i*N+j+1] = tmp;\n"
		"      		}\n"
		"	    }\n"
		"	 }\n"
		"   }\n"
		"}\n"
		"";

/*
 * makeProjection()
 * Forms E and E^T matrices from eigenvectors
 * float** eT: E^T, populated by function
 * float** e: E, populated by function
 * float** eigenvec: matrix of eigenvectors, unsorted
 * int* indices: indices to accept from eigenvectors
 * int N: degrees of freedom
*/


const string CudaFBMKernelSources::project = "__global__ void makeProjection(float* eT, float* e, float* eigenvec, int* indices, int M, int N)\n"
		"{\n"
		"    int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"    if (elementNum >= M*N) return;\n"
		"    int m = elementNum / N;\n"
		"    int n = elementNum % N;\n"
		"    e[n*M+m] = eigenvec[n*M+indices[m]];\n"
		"    eT[m*N+n] = e[n*M+m];\n"
		"}\n"
		"\n"
		"__global__ void makeHE(float* HE, float* force1, float4* force2, float* masses, float eps, int k, int m, int N) {\n"
		"   int elementNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   int atom = elementNum / 3;\n"
		"   if (elementNum >= N) return;\n"
		"\n"
		"   int axis = elementNum % 3;\n"
		"   if (axis == 0)\n"
		"      HE[elementNum*m+k] = (force1[elementNum] - force2[atom].x) / (sqrt(masses[atom]) * 1.0 * eps);\n"
		"   else if (axis == 1)\n"
		"      HE[elementNum*m+k] = (force1[elementNum] - force2[atom].y) / (sqrt(masses[atom]) * 1.0 * eps);\n"
		"   else\n"
		"      HE[elementNum*m+k] = (force1[elementNum] - force2[atom].z) / (sqrt(masses[atom]) * 1.0 * eps);\n"
		"}\n"
		"";

/* Create degrees of freedom vectors */
//__global__ void geometricDOF(float*** Qi_gdof, float* positions, float* masses, int* blocknums, int* blocksizes, float* norm, float** pos_center) {
const string CudaFBMKernelSources::dof = "__global__ void computeNormsAndCenter(float* norms, float* center, float* masses, float4* positions, int* blocknums, int* blocksizes) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   float totalmass = 0.0;\n"
		"   for( int j = blocknums[blockNum]; j <= blocknums[blockNum]+blocksizes[blockNum]-1; j += 3 ) {\n"
		"      float mass = masses[ j / 3 ];\n"
		"      center[blockNum*3+0] = positions[j/3].x*mass;\n"
		"      center[blockNum*3+1] = positions[j/3].y*mass;\n"
		"      center[blockNum*3+2] = positions[j/3].z*mass;\n"
		"      totalmass += mass;\n"
		"   }\n"
		"\n"
		"   norms[blockNum] = sqrt(totalmass);\n"
		"   center[blockNum*3+0] /= totalmass;\n"
		"   center[blockNum*3+1] /= totalmass;\n"
		"   center[blockNum*3+2] /= totalmass;\n"
		"}\n"
		"\n"
		"__global__ void geometricDOF(float* Qi_gdof, float4* positions, float* masses, int* blocknums, int* blocksizes, int largestsize, float* norm, float* pos_center) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   for (int j = 0; j < blocksizes[blockNum]-3; j += 3) {\n"
		"\n"
		"      int atom = ( blocknums[blockNum] + j ) / 3;\n"
		"      float mass = masses[atom];\n"
		"      float factor = sqrt( mass ) / norm[atom];\n"
		"\n"
		"            Qi_gdof[blockNum*largestsize*6 + j*6 + 0]   = factor;\n"
		"	    Qi_gdof[blockNum*largestsize*6 + (j+1)*6 + 1] = factor;\n"
		"	    Qi_gdof[blockNum*largestsize*6 + (j+2)*6 + 2]= factor;\n"
		"\n"
		"      float diff0 = positions[atom].x - pos_center[atom*3+0];\n"
		"      float diff1 = positions[atom].y - pos_center[atom*3+1];\n"
		"      float diff2 = positions[atom].z - pos_center[atom*3+2];\n"
		"\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j+1)*6 + 3] = diff2 * factor;\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j+2)*6 + 3] = -diff1 * factor;\n"
		"\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j)*6 + 4] = -diff2 * factor;\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j+2)*6 + 4] = -diff0 * factor;\n"
		"\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j)*6 + 5] = diff1 * factor;\n"
		"      Qi_gdof[blockNum*largestsize*6 + (j+1)*6 + 5] = -diff0 * factor;\n"
		"  }\n"
		"   float rotnorm = 0.0;\n"
		"   for (int j = 0; j < blocksizes[blockNum]; j++) \n"
		"      rotnorm += Qi_gdof[blockNum*largestsize*6 +j*6+3] * Qi_gdof[blockNum*largestsize*6+j*6+3];\n"
		"\n"
		"   rotnorm = 1.0 / sqrt (rotnorm);\n"
		"\n"
		"   for (int j = 0; j < blocksizes[blockNum]; j++)\n"
		"      Qi_gdof[blockNum*largestsize*6+j*6+3] *= rotnorm;\n"
		"}\n"
		"";

/* Assumes eigvec is sorted */
const string CudaFBMKernelSources::orthogonalize = "__global__ void orthogonalize23(float* Qi_gdof, int* blocksizes, int numblocks, int largestblock) {\n"
		"   int i = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"   for (int j = 4; j < 6; j++) {\n"
		"   for( int k = 3; k < j; k++ ) { // <-- vectors we're orthognalizing against\n"
		"      float dot_prod = 0.0;\n"
		"      for (int l = 0; l < blocksizes[i]; l++)\n"
		"	 dot_prod += Qi_gdof[i*6*largestblock + l*6 + k] * Qi_gdof[i*6*largestblock + l*6 + j];\n"
		"         //dot_prod += Qi_gdof[i][l][k] * Qi_gdof[i][l][j];\n"
		"      for (int l = 0; l < blocksizes[i]; l++)\n"
		"         Qi_gdof[i*6*largestblock + l*6 + j] -= Qi_gdof[i*6*largestblock + l*6 + k] * dot_prod;\n"
		"         //Qi_gdof[i][l][j] -= Qi_gdof[i][l][k] * dot_prod;\n"
		"   }\n"
		"\n"
		"   float rotnorm = 0.0;\n"
		"   for (int l = 0; l < blocksizes[i]; l++)\n"
		"      rotnorm += Qi_gdof[i*6*largestblock + l*6 + j] * Qi_gdof[i*6*largestblock + l*6 + j];\n"
		"      //rotnorm += Qi_gdof[i][l][j] * Qi_gdof[i][l][j];\n"
		"\n"
		"   rotnorm = 1.0 / sqrt(rotnorm);\n"
		"\n"
		"   for (int l = 0; l < blocksizes[i]; l++)\n"
		"      Qi_gdof[i*6*largestblock + l*6 + j] *= rotnorm;\n"
		"      //Qi_gdof[i][l][j] *= rotnorm;\n"
		"      }\n"
		"}\n"
		"\n"
		"\n"
		"__global__ void orthogonalize(float* eigvec, float* Qi_gdof, int cdof, int* blocksizes, int* blocknums, int largestblock) {\n"
		"   int blockNum = blockIdx.x * blockDim.x + threadIdx.x;\n"
		"\n"
		"        // orthogonalize original eigenvectors against gdof\n"
		"        // number of evec that survive orthogonalization\n"
		"        int curr_evec = 6;\n"
		"	int size = blocksizes[blockNum];\n"
		"        int startatom = blocknums[blockNum] / 3;\n"
		"        for( int j = 0; j < size; j++ ) { // <-- vector we're orthogonalizing\n"
		"            // to match ProtoMol we only include size instead of size + cdof vectors\n"
		"            // Note: for every vector that is skipped due to a low norm,\n"
		"            // we add an additional vector to replace it, so we could actually\n"
		"            // use all size original eigenvectors\n"
		"            if( curr_evec == size ) {\n"
		"                break;\n"
		"            }\n"
		"\n"
		"            // orthogonalize original eigenvectors in order from smallest magnitude\n"
		"            // eigenvalue to biggest\n"
		"	    // TMC The eigenvectors are sorted now\n"
		"            //int col = sortedPairs.at( j ).second;\n"
		"\n"
		"            // copy original vector to Qi_gdof -- updated in place\n"
		"            for( int l = 0; l < size; l++ ) {\n"
		"	        //Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] = eigvec[blocknums[blockNum]+l][j];\n"
		"	        Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] = eigvec[(blocknums[blockNum]+l)*largestblock+j];\n"
		"            }\n"
		"\n"
		"            // get dot products with previous vectors\n"
		"            for( int k = 0; k < curr_evec; k++ ) { // <-- vector orthog against\n"
		"                // dot product between original vector and previously\n"
		"                // orthogonalized vectors\n"
		"                double dot_prod = 0.0;\n"
		"                for( int l = 0; l < size; l++ ) {\n"
		"                    //dot_prod += Qi_gdof[blockNum*6*largestblock+l*6+k] * eigvec[blocknums[blockNum]+l][j];\n"
		"                    dot_prod += Qi_gdof[blockNum*6*largestblock+l*6+k] * eigvec[(blocknums[blockNum]+l)*largestblock+j];\n"
		"                }\n"
		"\n"
		"                // subtract from current vector -- update in place\n"
		"                for( int l = 0; l < size; l++ ) {\n"
		"                    Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] = Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] - Qi_gdof[blockNum*6*largestblock+l*6+k] * dot_prod;\n"
		"                }\n"
		"            }\n"
		"\n"
		"            //normalize residual vector\n"
		"            double norm = 0.0;\n"
		"            for( int l = 0; l < size; l++ ) {\n"
		"                norm += Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] * Qi_gdof[blockNum*6*largestblock+l*6+curr_evec];\n"
		"            }\n"
		"\n"
		"            // if norm less than 1/20th of original\n"
		"            // continue on to next vector\n"
		"            // we don't update curr_evec so this vector\n"
		"            // will be overwritten\n"
		"            if( norm < 0.05 ) {\n"
		"                continue;\n"
		"            }\n"
		"\n"
		"            // scale vector\n"
		"            norm = sqrt( norm );\n"
		"            for( int l = 0; l < size; l++ ) {\n"
		"                Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] = Qi_gdof[blockNum*6*largestblock+l*6+curr_evec] / norm;\n"
		"            }\n"
		"\n"
		"            curr_evec++;\n"
		"        }\n"
		"        \n"
		"        // 4. Copy eigenpairs to big array\n"
		"        //    This is necessary because we have to sort them, and determine\n"
		"        //    the cutoff eigenvalue for everybody.\n"
		"        // we assume curr_evec <= size\n"
		"        for( int j = 0; j < curr_evec; j++ ) {\n"
		"            //eval[startatom + j] = di[col]; No longer necessary\n"
		"\n"
		"            // orthogonalized eigenvectors already sorted by eigenvalue\n"
		"            for( int k = 0; k < size; k++ ) {\n"
		"                //eigvec[startatom + k][startatom + j] = Qi_gdof[blockNum*6*largestblock+k*6+j];\n"
		"                eigvec[(startatom + k)*largestblock+(startatom + j)] = Qi_gdof[blockNum*6*largestblock+k*6+j];\n"
		"            }\n"
		"        }\n"
		"}\n"
		"";

const string CudaFBMKernelSources::qr = "__device__ void run8_2_2_eVects(float* C,float* v,const int length,int p,int q, float* A,int t_width){\n"
										"    if(q != 0)\n"
										"	q = q-1;\n"
										"    int n=length-p-q;\n"
										"    int k, startX, startY, i;\n"
										"    int inx = threadIdx.x, iny = threadIdx.y;\n"
										"    startX = inx*t_width;\n"
										"    startY = iny*t_width;\n"
										"    float tau,c,s,t11,t12,t22;\n"
										"    t22 = C[p+n-1];\n"
										"    t11 = C[p+n-2];\n"
										"    t12 = v[p+n-1];\n"
										"    float d = (t11 - t22)/2;\n"
										"    float mu = t22 - t12*t12/(d+(d>0.0f ? 1.0f:-1.0f)*sqrt(d*d + t12*t12));\n"
										"    float x = C[p] - mu;\n"
										"    float z = v[p];\n"
										"    // We are repurposing d, so set it to zero\n"
										"    d = 0.0f;\n"
										"    for(k=0;k<n-1;k++){\n"
										"	// givens function:\n"
										"	if(z == 0.0f){\n"
										"	    c = 1.0f;\n"
										"	    s = 0.0f;\n"
										"    	}\n"
										"	else{\n"
										"	    if(abs(z) > abs(x)){\n"
										"    		tau = -x/z;\n"
										"	    	s = 1/sqrt(1+tau*tau);\n"
										"		c = s*tau;\n"
										"	    }\n"
										"	    else{\n"
										"    		tau = -z/x;\n"
										"		c = 1/sqrt(1+tau*tau);\n"
										"		s = c*tau;\n"
										"	    }\n"
										"	}\n"
										"	// T = GtTG, G = G(k,k+1,omega) (givens rotation)\n"
										"	// Before we start changing stuff, sync up\n"
										"	if(k < n-2)\n"
										"    	    z = -s*v[p+k+1];\n"
										"	__syncthreads();\n"
										"	if(inx == iny && inx == 1){\n"
										"	    t11 = C[p+k];\n"
										"	    t12 = v[p+k];\n"
										"	    t22 = C[p+k+1];\n"
										"	    if(k != 0){\n"
										"		v[p+k-1] = c*v[p+k-1]-s*d;\n"
										"	    }\n"
										"	    if(k < n-2){\n"
										"		v[p+k+1] = c*v[p+k+1];\n"
										"	    }\n"
										"	    C[p+k] = c*c*t11 - 2*s*c*t12 + s*s*t22;\n"
										"	    v[p+k] = c*s*t11 + (c*c-s*s)*t12 - s*c*t22;\n"
										"	    C[p+k+1] = s*s*t11 + 2*s*c*t12 + c*c*t22;\n"
										"	}\n"
										"	else if(inx == 0 && iny == 0){\n"
										"	    // use these to hold things while we change them\n"
										"	    t11 = A[length*(p+k)+p+k];\n"
										"	    tau = A[length*(p+k+1)+p+k]; // Here, tau is t21 - no symmetry\n"
										"	    t12=A[length*(p+k)+p+k+1];\n"
										"	    t22=A[length*(p+k+1)+p+k+1];\n"
										"	    // Now, make changes\n"
										"	    A[length*(p+k)+p+k]=c*c*t11 + s*c*tau - s*c*t12 - s*s*t22;\n"
										"	    A[length*(p+k+1)+p+k]=-s*c*t11 + c*c*tau + s*s*t12 - s*c*t22;\n"
										"	    A[length*(p+k)+p+k+1]=s*c*t11 + s*s*tau + c*c*t12 + s*c*t22;\n"
										"	    A[length*(p+k+1)+p+k+1]=-s*s*t11 + c*s*tau -s*c*t12 + c*c*t22;\n"
										"	    for(i=startX+2;i<startX+t_width;i++){\n"
										"		t11 = A[length*(p+k) + (p+k+i)%length];\n"
										"		tau = A[length*(p+k+1) + (p+k+i)%length];\n"
										"		A[length*(p+k) + (p+k+i)%length] = c*t11 + s*tau;\n"
										"		A[length*(p+k+1) + (p+k+i)%length] = -s*t11 + c*tau;\n"
										"	    }\n"
										"	    for(i=startY+2;i<startY+t_width;i++){\n"
										"		t11 = A[length*((p+k+i)%length) + p+k];\n"
										"		t12 = A[length*((p+k+i)%length) + p+k+1];\n"
										"		A[length*((p+k+i)%length) + p+k] = c*t11 - s*t12;\n"
										"		A[length*((p+k+i)%length) + p+k+1] = s*t11 + c*t12;\n"
										"	    }\n"
										"	}\n"
										"	else if(inx == 0){\n"
										"	    // In order to keep the previous loop in the middle, we have to do\n"
										"	    // some indexing tricks.  Basically, we just wrap around.\n"
										"	    for(i=startX;i<startX+t_width && i<length;i++){\n"
										"		t11 = A[length*(p+k) + (p+k+i)%length];\n"
										"		tau = A[length*(p+k+1) + (p+k+i)%length];\n"
										"		A[length*(p+k) + (p+k+i)%length] = c*t11 + s*tau;\n"
										"		A[length*(p+k+1) + (p+k+i)%length] = -s*t11 + c*tau;\n"
										"	    }\n"
										"	}\n"
										"	else if(iny == 0){\n"
										"	    for(i=startY;i<startY+t_width && i<length;i++){\n"
										"		t11 = A[length*((p+k+i)%length) + p+k];\n"
										"		tau = A[length*((p+k+i)%length) + p+k+1];\n"
										"		A[length*((p+k+i)%length) + p+k] = c*t11 - s*t12;\n"
										"		A[length*((p+k+i)%length) + p+k+1] = s*t11 + c*t12;\n"
										"	    }\n"
										"	}\n"
										"\n"
										"	__syncthreads();\n"
										"    	if(k < n-2){\n"
										"	    x = v[p+k];\n"
										"	    d = z;\n"
										"	}\n"
										"    }\n"
										"}\n"
										"\n"
										"__device__ void run8_2_2(float* matA,const int length,int p,int q){\n"
										"    if(q != 0)\n"
										"	q = q-1;\n"
										"    int n=length-p-q;\n"
										"    int k;\n"
										"    float tau,c,s,t11,t12,t22;\n"
										"    t22 = matA[(p+n-1)*length+p+n-1];\n"
										"    t11 = matA[length*(p+n-2)+p+n-2];\n"
										"    t12 = matA[length*(p+n-2)+p+n-1];\n"
										"    float d = (t11 - t22)/2;\n"
										"    float mu = t22 - t12*t12/(d+(d>0.0f ? 1.0f:-1.0f)*sqrt(d*d + t12*t12));\n"
										"    float x = matA[p*length+p] - mu;\n"
										"    float z = matA[p*length+p+1];\n"
										"    for(k=0;k<n-1;k++){\n"
										"	// givens function:\n"
										"	if(z == 0){\n"
										"	    c = 1;\n"
										"	    s = 0;\n"
										"    	}\n"
										"	else{\n"
										"	    if(abs(z) > abs(x)){\n"
										"    		tau = -x/z;\n"
										"	    	s = 1/sqrt(1+tau*tau);\n"
										"		c = s*tau;\n"
										"	    }\n"
										"	    else{\n"
										"    		tau = -z/x;\n"
										"		c = 1/sqrt(1+tau*tau);\n"
										"		s = c*tau;\n"
										"	    }\n"
										"	}\n"
										"	// T = GtTG, G = G(k,k+1,omega) (givens rotation)\n"
										"	t11 = matA[(p+k)*length+p+k];\n"
										"	t12 = matA[(p+k)*length+p+k+1];\n"
										"	t22 = matA[(p+k+1)*length+p+k+1];\n"
										"	if(k < n-2){\n"
										"	    matA[(p+k)*length+p+k+2] = -s*matA[(p+k+1)*length+p+k+2];\n"
										"	    matA[(p+k+1)*length+p+k+2] = c*matA[(p+k+1)*length+p+k+2];\n"
										"    	    matA[(p+k+2)*length+p+k+1] = matA[(p+k+1)*length+p+k+2];\n"
										"    	    matA[(p+k+2)*length+p+k] = matA[(p+k)*length+p+k+2];\n"
										"	}\n"
										"	if(k != 0){\n"
										"	    matA[(p+k-1)*length+p+k] = c*matA[(p+k-1)*length+p+k]-s*matA[(p+k-1)*length+p+k+1];\n"
										"	    matA[(p+k)*length+p+k+1] = matA[(p+k-1)*length+p+k];\n"
										"	    matA[(p+k-1)*length+p+k+1]=0.0f;\n"
										"	    matA[(p+k+1)*length+p+k-1]=0.0f;\n"
										"	}\n"
										"\n"
										"	matA[(p+k)*length+p+k] = c*c*t11 - 2*s*c*t12 + s*s*t22;\n"
										"	matA[(p+k)*length+p+k+1] = c*s*t11 + (c*c-s*s)*t12 - s*c*t22;\n"
										"	matA[(p+k+1)*length+p+k] = matA[(p+k)*length+p+k+1];\n"
										"	matA[(p+k+1)*length+p+k+1] = s*s*t11 + 2*s*c*t12 + c*c*t22;\n"
										"\n"
										"	if(k < n-2){\n"
										"	    x = matA[(p+k+1)*length+p+k];\n"
										"	    z = matA[(p+k+2)*length+p+k];\n"
										"	}\n"
										"    }\n"
										"}\n"
										"\n"
										"// Assuming these things:\n"
										"// A symmetric positive matrix (from the hessian)\n"
										"// The matrix will be small (40 to 200)\n"
										"// This function returns the eigenvalues and eigenvectors\n"
										"__device__ void hessian_qrf( const int n, float *A, const int t_width, float *C, const float eps){\n"
										"    const int inx = threadIdx.x;\n"
										"    const int iny = threadIdx.y;\n"
										"    float sum;\n"
										"    float vTv;\n"
										"    float pTv;\n"
										"    float mu;\n"
										"    int k,i,cur1,cur2,l,startX,startY;\n"
										"    extern __shared__ float v[];\n"
										"    float * p;\n"
										"    float * w;\n"
										"    p = v + n;\n"
										"    w = v + 2*n;\n"
										"    // Ensure we are in matrix (we don't have to worry about this anymore)\n"
										"    if(inx*t_width<n && iny*t_width<n){\n"
										"	// householder Tridiagonalization Algorithm 8.3.1\n"
										"	// 1. for loop\n"
										"	for(i=0;i<n-2;i++){\n"
										"	    // Keep these to tell if we are in the right spot\n"
										"	    cur1 = i/t_width;\n"
										"	    cur2 = (i+1)/t_width; // For when we need to check against i+1\n"
										"	    // find the start value for loops once\n"
										"	    startX =((inx*t_width) > i+1) ? (inx*t_width) : (i+1) ;\n"
										"	    startY =((iny*t_width) > i+1) ? (iny*t_width) : (i+1) ;\n"
										"	    // Reset these values\n"
										"	    sum=0.0f;\n"
										"	    vTv=0.0f;\n"
										"    	    pTv=0.0f;\n"
										"	    // 2. house(A,i); algorithm 5.1.1\n"
										"	    // length(v) = n-i\n"
										"	    // Check if in proper column and below diagonal\n"
										"	    if(iny == cur1 && inx >= cur2)\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    v[k] = A[k*n+i];\n"
										"	    __syncthreads();\n"
										"    	    for(k=i+1;k<n;k++)\n"
										"		sum+=v[k]*v[k];\n"
										"	    mu = sqrt(sum);\n"
										"	    // sum = beta\n"
										"	    sum = v[i+1]+mu*(v[i+1]>0.0f ? 1.0f:-1.0f);\n"
										"	    if(iny == cur1 && inx >= cur2)\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    v[k] = v[k]/sum;\n"
										"	    if(inx==cur2 && iny==cur1)\n"
										"		v[i+1]=1.0f;\n"
										"	    __syncthreads();\n"
										"	    // END house\n"
										"	    // 2.5 find v**T v = length of v\n"
										"	    for(k=i+1;k<n;k++)\n"
										"    		vTv += v[k]*v[k];\n"
										"	    // 3. find p = 2A(i+1:n,i+1:n)v/vTv\n"
										"	    if(inx>=cur2 && iny==cur1){\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++){\n"
										"		    p[k]=0.0f;\n"
										"		    for(l=i+1;l<n;l++)\n"
										"			p[k]=p[k]+2.0f*A[(k)*n+l]*v[l]/vTv;\n"
										"		}\n"
										"	    }\n"
										"	    __syncthreads();\n"
										"	    // 3.5 find pTv\n"
										"	    for(k=i+1;k<n;k++)\n"
										"    		pTv += p[k]*v[k];\n"
										"	    __syncthreads();\n"
										"	    // 4. find w\n"
										"	    if(inx>=cur2 && iny==cur1)\n"
										"		for(k=startX;k<n && k<(inx+1)*t_width;k++)\n"
										"		    w[k]=p[k]-pTv*v[k]/vTv;\n"
										"	    __syncthreads();\n"
										"	    // 5. find new A values\n"
										"	    if(inx>=cur2 && iny>=cur2)\n"
										"	    {\n"
										"		for(k=startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    for(l=startY;l<(iny+1)*t_width && l<n;l++)\n"
										"			A[k*n+l]=A[k*n+l]-v[k]*w[l] - w[k]*v[l];\n"
										"	    }\n"
										"	    // Track the subdiagonal values\n"
										"	    if( iny == cur1 && inx==cur1)\n"
										"		A[i*n + i+1] = mu;\n"
										"	    // Store the householder vectors in the matrix \n"
										"	    if(inx>=cur1 && iny == cur1)\n"
										"		for(k=startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    A[k*n+i] = v[k];\n"
										"	    __syncthreads();\n"
										"	}\n"
										"	// Here, we need to move the diagonals over to C...\n"
										"	// And store the subdiagonals into p.\n"
										"	// Do it with the threads in the middle.\n"
										"	if(inx == iny){\n"
										"	    for(k=inx*t_width;k<n && k<(inx+1)*t_width;k++){\n"
										"		C[k] = A[k*n+k];\n"
										"		if(k<n-1)\n"
										"		    p[k] = A[k*n+k+1];\n"
										"		A[k*n+k]=1.0f;\n"
										"	    }\n"
										"	}\n"
										"	__syncthreads();\n"
										"	// Here, we accumulate Q from householder\n"
										"	// Important to get this done AFTER copying diagonals\n"
										"	for(i=n-1;i>0;i--){\n"
										"	    // Page 199 of Golub: ( A begins as identity)\n"
										"	    // v[i] = 1; v[i+1:n] = A[i+1:n]\n"
										"	    // Page 197 of Golub: (row.house)\n"
										"	    // beta = -2/vTv ; w = beta ATv; A = A+vwT\n"
										"	    startX = (inx*t_width > i) ? inx*t_width : i;\n"
										"	    startY = (iny*t_width > i) ? iny*t_width : i;\n"
										"	    if(inx*t_width >= i && iny== i/t_width){\n"
										"		for(k = startX; k<n && k<(inx+1)*t_width; k++){\n"
										"		    if(k!=i){\n"
										"			v[k] = A[k*n+i];\n"
										"			// Set the values equal to zero\n"
										"			A[k*n+i] = 0.0f;\n"
										"			A[i*n+k] = 0.0f;\n"
										"		    }\n"
										"		}\n"
										"	    }\n"
										"\n"
										"	    __syncthreads();\n"
										"	    // Find vTv in each thread\n"
										"	    vTv = 0.0f;\n"
										"	    for(k=i;k<n;k++)\n"
										"		vTv = vTv + v[k]*v[k];\n"
										"	    // Find w cooperatively\n"
										"	    if(inx*t_width >= i && iny*t_width >= i){\n"
										"		// w = beta * AT * v\n"
										"		for(k = startX; k<n && k<(inx+1)*t_width; k++)\n"
										"		    w[k]=0.0f;\n"
										"		    for(l=startY; l<n && l<(iny+1)*t_width; l++)\n"
										"			w[k] = w[k]-2/vTv * A[l*n+k] * v[l];\n"
										"		__syncthreads();\n"
										"		// Calculate next A(bottom right matrix)\n"
										"		// A = A + v wT\n"
										"		for(k = startX; k<n && k<(inx+1)*t_width; k++)\n"
										"		    for(l=startY; l<n && l<(iny+1)*t_width; l++)\n"
										"			A[l*n+k] = A[l*n+k]+ v[l] * w[k];\n"
										"		__syncthreads();\n"
										"	    }\n"
										"	}\n"
										"	// QR Diagonalization\n"
										"	// Algorithm 8.2.3 in Golub\n"
										"	cur1 = 0; // cur1 = p\n"
										"	cur2 = 0; // cur2 = q\n"
										"	while(cur2<n){\n"
										"	    //1 a[i+1,i] and a[i,i+1] = 0 if a[i,i+1] <= eps(a[i,i]+a[i+1,i+1])\n"
										"	    //2 choose p,q such that T22 is unreduced(no zeros in subdiagonal)\n"
										"	    i=n-1;\n"
										"	    while(i>0 && abs(p[i-1])<eps*(abs(C[i-1])+abs(C[i]))){\n"
										"		if(iny == 0 && inx == 0)\n"
										"		    p[i-1] = 0.0f;\n"
										"		i--;\n"
										"	    }\n"
										"\n"
										"	    cur2 = n-i;\n"
										"\n"
										"	    while(i>0 && abs(p[i-1])>=(eps*(abs(C[i-1])+abs(C[i]))))\n"
										"		i--;\n"
										"	    cur1=i;\n"
										"	    //3 if q<n, do run8_2_2 on T22\n"
										"	    // Also, calculate eigenvectors\n"
										"	    if(cur2<n)\n"
										"    		run8_2_2_eVects(C,p,n,cur1,cur2,A,t_width);\n"
										"	    __syncthreads();\n"
										"	}\n"
										"    }\n"
										"}\n"
										"\n"
										"// Assuming these things:\n"
										"// A symmetric positive matrix (from the hessian)\n"
										"// The matrix will be small (40 to 200)\n"
										"// This function returns the eigenvalues in the C matrix\n"
										"__device__ void hessian_qrd( const int n, float *A, const int t_width, float *C, const float eps)\n"
										"{\n"
										"    const int inx = threadIdx.x;\n"
										"    const int iny = threadIdx.y;\n"
										"    float sum;\n"
										"    float vTv;\n"
										"    float pTv;\n"
										"    float mu;\n"
										"    int k,i,cur1,cur2,l,startX,startY;\n"
										"    extern __shared__ float v[];\n"
										"    float * p;\n"
										"    float * w;\n"
										"    p = v + n;\n"
										"    w = v + 2*n;\n"
										"    // Ensure we are in matrix (we don't have to worry about this anymore)\n"
										"    if(inx*t_width<n && iny*t_width<n){\n"
										"	// householder Tridiagonalization Algorithm 8.3.1\n"
										"	// 1. for loop\n"
										"	for(i=0;i<n-2;i++){\n"
										"	    // Keep these to tell if we are in the right spot\n"
										"	    cur1 = i/t_width;\n"
										"	    cur2 = (i+1)/t_width; // For when we need to check against i+1\n"
										"	    // find the start value for loops once\n"
										"	    startX =((inx*t_width) > i+1) ? (inx*t_width) : (i+1) ;\n"
										"	    startY =((iny*t_width) > i+1) ? (iny*t_width) : (i+1) ;\n"
										"	    // Reset these values\n"
										"	    sum=0.0f;\n"
										"	    vTv=0.0f;\n"
										"    	    pTv=0.0f;\n"
										"	    // 2. house(A,i); algorithm 5.1.1\n"
										"	    // length(v) = n-i\n"
										"	    // Check if in proper column and below diagonal\n"
										"	    if(iny == cur1 && inx >= cur2)\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    v[k] = A[k*n+i];\n"
										"	    __syncthreads();\n"
										"    	    for(k=i+1;k<n;k++)\n"
										"		sum+=v[k]*v[k];\n"
										"	    mu = sqrt(sum);\n"
										"	    // sum = beta\n"
										"	    sum = v[i+1]+mu*(v[i+1]>0.0f ? 1.0f:-1.0f);\n"
										"	    __syncthreads();\n"
										"	    if(iny == cur1 && inx >= cur2)\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    v[k] = v[k]/sum;\n"
										"	    if(inx==cur2 && iny==cur1)\n"
										"		v[i+1]=1.0f;\n"
										"	    __syncthreads();\n"
										"	    // END house\n"
										"	    // 2.5 find v**T v = length of v\n"
										"	    for(k=i+1;k<n;k++)\n"
										"    		vTv += v[k]*v[k];\n"
										"	    // 3. find p = 2A(i+1:n,i+1:n)v/vTv\n"
										"	    if(inx>=cur2 && iny==cur1){\n"
										"		for(k = startX;k<(inx+1)*t_width && k<n;k++){\n"
										"		    p[k]=0.0f;\n"
										"		    for(l=i+1;l<n;l++)\n"
										"			p[k]=p[k]+2.0f*A[(k)*n+l]*v[l]/vTv;\n"
										"		}\n"
										"\n"
										"	    }\n"
										"	    __syncthreads();\n"
										"	    // 3.5 find pTv\n"
										"	    for(k=i+1;k<n;k++)\n"
										"    		pTv += p[k]*v[k];\n"
										"	    __syncthreads();\n"
										"	    // 4. find w\n"
										"	    if(inx>=cur2 && iny==cur1)\n"
										"		for(k=i+1;k<n && k<(inx+1)*t_width;k++)\n"
										"		    w[k]=p[k]-pTv*v[k]/vTv;\n"
										"	    __syncthreads();\n"
										"	    // 5. find new A values\n"
										"	    if(inx>=cur2 && iny>=cur2)\n"
										"	    {\n"
										"		for(k=startX;k<(inx+1)*t_width && k<n;k++)\n"
										"		    for(l=startY;l<(iny+1)*t_width && l<n;l++)\n"
										"			A[k*n+l]=A[k*n+l]-v[k]*w[l] - w[k]*v[l];\n"
										"	    }\n"
										"	    if( iny == cur1 && inx==cur1){\n"
										"		A[(i+1)*n + i] = mu;\n"
										"		A[(i)*n + i+1] = mu;\n"
										"	    }\n"
										"	    __syncthreads();\n"
										"	}\n"
										"	// QR Diagonalization\n"
										"	// Algorithm 8.2.3 in Golub\n"
										"	cur1 = 0; // cur1 = p\n"
										"	cur2 = 0; // cur2 = q\n"
										"	while(cur2<n){\n"
										"	    //1 a[i+1,i] and a[i,i+1] = 0 if a[i,i+1] <= eps(a[i,i]+a[i+1,i+1])\n"
										"	    //2 choose p,q such that T22 is unreduced(no zeros in subdiagonal)\n"
										"	    i=n-1;\n"
										"	    while(i>0){\n"
										"		if(abs(A[i*n+i-1])<=eps*(abs(A[i*n+i])+abs(A[(i+1)*n+i+1])))\n"
										"		    A[i*n+i-1] = 0.0f;\n"
										"		else\n"
										"		    break;\n"
										"		i--;\n"
										"	    }\n"
										"\n"
										"	    cur2 = n-i;\n"
										"\n"
										"	    while(i>0 && abs(A[i*n+i-1])>=(eps*(abs(A[i*n+i])+abs(A[(i+1)*n+i+1]))))\n"
										"		i--;\n"
										"	    cur1=i;\n"
										"	    //3 if q<n, do run8_2_2 on T22\n"
										"	    if(cur2<n && iny==inx && inx==0)\n"
										"		run8_2_2(A,n,cur1,cur2);\n"
										"	    __syncthreads();\n"
										"	}\n"
										"	if(iny == inx){\n"
										"	    for(i=inx*t_width; i<n && i<(inx+1)*t_width; i++){\n"
										"		C[i] = A[i*n+i];\n"
										"	    }\n"
										"	}\n"
										"    }\n"
										"}\n"
										"\n"
										"// block_QR( const int n_mat, float *mat, const int* idxs, const int* sizes)\n"
										"//ARGUMENTS:\n"
										"//    n_mat: The number of matrices to be diagonalized\n"
										"//    mat: The matrices to be diagonalized, stored in consecutive memory\n"
										"//    idxs: Array containing indices of the starting point of each matrix\n"
										"//    sizes: Array containing the size of each matrix (total number of elements)\n"
										"//    evals: array containing the space to store the final eigenvectors.\n"
										"//    EVECTS: boolean telling us whether to collect the eigenvectors.\n"
										"??\n"
										"__global__ void block_QR( const int n_mat, float *mat,const int* idxs, const int* sizes, float* evals, const int* eval_idxs,const int EVECTS, const float eps){\n"
										"    if(blockIdx.x < n_mat){\n"
										"	int t_width = sizes[blockIdx.x]/blockDim.x+1;\n"
										"	if(EVECTS<0)\n"
										"	    hessian_qrd(sizes[blockIdx.x],mat+idxs[blockIdx.x],t_width,evals+eval_idxs[blockIdx.x], eps);\n"
										"	else\n"
										"	    hessian_qrf(sizes[blockIdx.x],mat+idxs[blockIdx.x],t_width,evals+eval_idxs[blockIdx.x], eps);\n"
										"    }\n"
										"}\n"
										"\n"
										"__global__ void block_QR_EVal_only( const int n_mat, float *mat, const int* idxs, const int* sizes, const float eps){\n"
										"	float* evals=mat;\n"
										"	int t_width = sizes[blockIdx.x]/blockDim.x+1;\n"
										"    	hessian_qrd(sizes[blockIdx.x],mat+idxs[blockIdx.x],t_width,evals, eps);\n"
										"}\n"
										"\n"
										"";
